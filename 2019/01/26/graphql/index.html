<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="导读本篇文章主要是为了宣导 GraphQL 技术，包含了介绍 GraphQL 能解决的问题和尚不完善的地方，以及我们团队在实际业务场景中的实践总结。希望读者能通过这篇文章，了解到 GraphQL 的优缺点，在遇到合适的场景中能多一个技术选择，并在日后的实践过程能有所参考，避免重复踩坑。 背景目前在我们绝大多数的场景中，后端提供的接口是基于 RESTful 风格的接口，而 RESTful 架构风格的">
<meta name="keywords" content="justin, yang, yijie yang, iOS, Web, front-end">
<meta property="og:type" content="article">
<meta property="og:title" content="GraphQL - 一种用于 API 的查询语言">
<meta property="og:url" content="https://yang2012.github.io/2019/01/26/graphql/index.html">
<meta property="og:site_name" content="Justin Yang">
<meta property="og:description" content="导读本篇文章主要是为了宣导 GraphQL 技术，包含了介绍 GraphQL 能解决的问题和尚不完善的地方，以及我们团队在实际业务场景中的实践总结。希望读者能通过这篇文章，了解到 GraphQL 的优缺点，在遇到合适的场景中能多一个技术选择，并在日后的实践过程能有所参考，避免重复踩坑。 背景目前在我们绝大多数的场景中，后端提供的接口是基于 RESTful 风格的接口，而 RESTful 架构风格的">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/128052124.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/128052144.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/128103910.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/128057823.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/128104064.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/136637568.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/136673448.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/128198702.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/128260354.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/144971891.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/134899495.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/134914845.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/134897956.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/135033258.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/134950238.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/135033459.png">
<meta property="og:image" content="https://yang2012.github.io/images/post/graphql/134924789.png">
<meta property="og:updated_time" content="2019-04-28T09:54:47.165Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GraphQL - 一种用于 API 的查询语言">
<meta name="twitter:description" content="导读本篇文章主要是为了宣导 GraphQL 技术，包含了介绍 GraphQL 能解决的问题和尚不完善的地方，以及我们团队在实际业务场景中的实践总结。希望读者能通过这篇文章，了解到 GraphQL 的优缺点，在遇到合适的场景中能多一个技术选择，并在日后的实践过程能有所参考，避免重复踩坑。 背景目前在我们绝大多数的场景中，后端提供的接口是基于 RESTful 风格的接口，而 RESTful 架构风格的">
<meta name="twitter:image" content="https://yang2012.github.io/images/post/graphql/128052124.png">





  
  
  <link rel="canonical" href="https://yang2012.github.io/2019/01/26/graphql/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>GraphQL - 一种用于 API 的查询语言 | Justin Yang</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Justin Yang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">hello world</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yang2012.github.io/2019/01/26/graphql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Justin Yang">
      <meta itemprop="description" content="Blog and website of Justin Yang, blogging mainly for tech. Opinions expressed are mine.">
      <meta itemprop="image" content="/images/default_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Justin Yang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">GraphQL - 一种用于 API 的查询语言

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-26 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-26T00:00:00+08:00">2019-01-26</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>本篇文章主要是为了宣导 GraphQL 技术，包含了介绍 GraphQL 能解决的问题和尚不完善的地方，以及我们团队在实际业务场景中的实践总结。希望读者能通过这篇文章，了解到 GraphQL 的优缺点，在遇到合适的场景中能多一个技术选择，并在日后的实践过程能有所参考，避免重复踩坑。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前在我们绝大多数的场景中，后端提供的接口是基于 RESTful 风格的接口，而 RESTful 架构风格的服务是围绕资源展开的。随着业务复杂度的提高，前端页面信息和交互体验的愈加复杂，RESTfull风格的接口，在实际研发场景下，通常会遇到以下几处痛点：</p>
<a id="more"></a>
<p>1.性能瓶颈<br>后端往往是采取微服务架构，拆分成多个服务，一个页面往往需要发送多个请求，才能获取足够的数据。而对于同一个接口，如果参数有多种组合，也需要调用多次才可。<br>请求的数量愈多，以下的耗时愈多：</p>
<ul>
<li>队列等待时间（浏览器对同一个主机域名的并发连接数有限制）</li>
<li>链接建立和销毁耗时</li>
<li>后端重复的权限或参数校验</li>
<li>客户端与服务器之间来回响应时间</li>
</ul>
<p>2.数据冗余<br>后端提供的接口，通常会在多个场景（或页面）中使用，后端同学无法事先预知前端需要哪些数据，因此基本都是返回大而全的信息，宁多勿缺。随着业务的发展，会加入更多的数据，而且为了保持兼容性，基本只增不减。</p>
<p>3.文档缺失<br>文档跟接口分离，无法直观通过接口或者单个文档获取所有需要的接口信息。同时，文档很难与实现完全保持一致，基本依靠人工来保证信息的准确性和及时性，不可靠。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="/images/post/graphql/128052124.png" alt="graphql"></p>
<p>作为 Facebook 在 2015 年推出的查询语言，GraphQL 能够对 API 中的数据提供一套易于理解的完整描述，使得前端能够更加准确的获得它需要的数据，目前包括 Facebook、Twitter、GitHub 在内的很多公司都已经在生产环境使用 GraphQL 提供 API。<br>以下是官方对 GraphQL 的定义</p>
<blockquote>
<p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p>
</blockquote>
<p><img src="/images/post/graphql/128052144.png" alt="graphql"></p>
<p>GraphQL 的强大表达能力主要还是来自于它完备的类型系统，与 REST 不同，它将整个 Web 服务中的全部资源看成一个有连接的图，而不是一个个资源孤岛，在访问任何资源时都可以通过资源之间的连接访问其它的资源。<br>举个例子，假如我们有以下的结构</p>
<p><img src="/images/post/graphql/128103910.png" alt="graphql"></p>
<p>当我们访问 User 资源时，就可以通过 GraphQL 中的连接访问当前 User 的 Repo 和 Issue 等资源，我们不再需要通过多个 REST 的接口分别获取这些资源，只需要通过如下所示的查询就能一次性拿到全部的结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    user &#123;</span><br><span class="line">        id</span><br><span class="line">        email</span><br><span class="line">        username</span><br><span class="line">        repos(first: 10) &#123;</span><br><span class="line">            id</span><br><span class="line">            url</span><br><span class="line">            name</span><br><span class="line">            issues(first: 20) &#123;</span><br><span class="line">                id</span><br><span class="line">                author</span><br><span class="line">                title</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GraphQL 这种方式能够将原有 RESTful 风格时的多次请求聚合成一次请求，不仅能够减少多次请求带来的延迟，还能够降低服务器压力，加快前端的渲染速度。<br>此外，它的类型系统也非常丰富，除了标量、枚举、列表和对象等类型之外，还支持接口和联合类型等高级特性。</p>
<p><img src="/images/post/graphql/128057823.png" alt="graphql"></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>与 RESTful 最明显的不同，是每一个的 GraphQL 服务其实对外只提供了一个用于调用内部接口的端点，所有的请求都访问这个暴露出来的唯一端点。</p>
<p><img src="/images/post/graphql/128104064.png" alt="graphql"></p>
<p>GraphQL 实际上将多个 HTTP 请求聚合成了一个请求，它只是将多个 RESTful 请求的资源变成了一个从根资源 Post 访问其他资源的 Comment 和 Author 的图，多个请求变成了一个请求的不同字段，从原有的分散式请求变成了集中式的请求，这种方式非常适合单体服务直接对外提供 GraphQL 服务，能够在数据源和展示层建立一个非常清晰的分离，同时也能够通过一些强大的工具，例如 GraphiQL 直接提供可视化的文档。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.数据的关联性和结构化更好<br>RESTful 所操作的资源相对是离散的；而 GraphQL 的数据更有整体性。<br>举个例子，如果要获取 A 的朋友的朋友，用 RESTful 该怎么做呢？<br>假设我们有这样一个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /user/:userId/friends/</span><br></pre></td></tr></table></figure>
<p>而 A 有 20 个好朋友，那么我们总共需要发送 20 + 1 = 21 次 REST 请求。<br>为了减少请求数量，为了这种特殊场景，通常会设计出以下这种接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /user/:userId/friendsAndHisFriends/</span><br></pre></td></tr></table></figure>
<p>而这种情况如果是在 GraphQL 中，会怎么做呢？<br>首先我们需要给 User 定义 Schema (GraphQL 有一套完整的类型系统)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [User]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们在 Graph root 上只挂了一个 Node，叫 user:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  user(id: ID!): User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们从客户端发送的 query 就可以写成这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">query ($userId: ID) &#123;</span><br><span class="line">  user(id: $userId) &#123;</span><br><span class="line">    name</span><br><span class="line">    friends &#123;</span><br><span class="line">      name</span><br><span class="line">      friends &#123;</span><br><span class="line">        name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这一个请求就可以完成查询朋友的朋友这种头疼的需求。</p>
<p>2.精准地数据获取</p>
<ul>
<li>声明式 (Declarative) 获取数据，非常直观和精准</li>
<li>可以自主控制需要获取的数据，数据刚刚好，不多也不少</li>
<li>数据模型之间可以建立连接关系，大幅減少来回请求的数量</li>
</ul>
<p>相比之下 RESTful API 就需要来回多次才能够获取足够的数据，并且大多数情况下会携带额外的数据，缺乏弹性 (multiple round-trips) 。</p>
<p>3.代码即文档<br>能够有效减少前后端的沟通成本，建立文档的时间成本基本为0。</p>
<p>4.提高前端控制权<br>以前为了适应不同的平台或者不同版本的需要，需要新开API，或者API中做平台/版本判断来控制返回值<br>而 GraphQL API 则只需要一套API，由前端开发来决定需要获取那些数据，并且可以预期对返回的数据的格式和内容</p>
<p>5.高度自由的实现方式<br>不依赖于某种语言，GraphQL 让你的整个应用共享一套 API，而不用被限制于特定存储引擎。GraphQL 引擎已经有多种语言实现，通过 GraphQL API 能够更好利用你的现有数据和代码。你只需要为类型系统的字段编写函数，GraphQL 就能通过优化并发的方式来调用它们。</p>
<p>6.强类型 (Strongly Typed)<br>一切面向前端的接口都有强类型的 Schema 做保证，且完整类型定义因 introspection 完全对前端可见，一旦前端发送的 query 与 Schema 不符，能快速感知到产生了错误。<br>支持五种基础类型 (Scalar Types)，以及自定义类型</p>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p>1.学习成本</p>
<ul>
<li>如果要应用到整个公司或者基础架构上，仍需要时间来推广和谨慎的技术方案讨论</li>
<li>很容易就会陷入 RESTful API 设计思维，埋下技术债</li>
<li>很多处理方式，如执行效率、错误处理、权限控制等，需要额外的学习</li>
</ul>
<p>2.缺少官方实现<br>目前 FB 官方就只有一个 Node.js 的 reference implementation，其他语言都是社区爱好者自己搞的。另外，GraphQL 在前端如何与视图层、状态管理方案结合，目前也只有 React/Relay 这个一个官方方案。</p>
<p>3.过于自由、规范少</p>
<ul>
<li>没有一个成熟的Best Practice时，容易出现Anti Pattern</li>
<li>没有一定的设计规范，容易设计出过于复杂的Scheme</li>
</ul>
<p>在实现 GraphQL 服务端接口时，很容易就会写出效率极差的代码，引起 “N+1 问题”。GraphQL 的 field resolve 如果按照 naive 的方式来写，每一个 field 解析都执行一遍数据库的话，会产生大量冗余 query，虽然网络层面的请求数被优化了，但数据库查询可能会成为性能瓶颈，这块虽然可以优化，但并不是那么容易做。</p>
<p>数据库层面的 N + 1 查询我们可以通过减少 SQL 查询的次数来解决，一般我们会将多个 = 查询转换成 IN 查询；但是 GraphQL 中的 N + 1 问题就有些复杂了，尤其是当资源需要通过 RPC 请求从其他微服务中获取时，更不能通过简单的改变 SQL 查询来解决。</p>
<p>目前业界常用的解决方案是通过使用了 DataLoader 从业务层面解决了 N + 1 问题，其核心逻辑就是整合多个请求，通过批量请求的方式解决问题。</p>
<blockquote>
<p>DataLoader is a generic utility to be used as part of your application’s data fetching layer to provide a simplified and consistent API over various remote data sources such as databases or web services via batching and caching.</p>
</blockquote>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在业务复杂性指数提升的今天，微服务架构成为了解决某些问题时必不可少的解决方案，因此，在实际应用中，如何在微服务架构中使用 GraphQL 提高前后端之间的沟通效率并降低开发成本成为了一个值得考虑的问题。<br>微服务架构是希望将大服务拆分成多个自恰的微服务，而Graphql 则希望将数据都进行汇集，一个强调拆，一个强调合，其中会有一些碰撞，解决的关键就在于如何设计schema。<br>从总体来看，微服务架构暴露的 GraphQL 接口应该只有两种：<br>一种接口是分散式的，每一个微服务对外暴露不同的端点，分别对外界提供服务。</p>
<p><img src="/images/post/graphql/136637568.png" alt="graphql"></p>
<p>在这种情况下，流量的路由是根据用户请求的不同服务进行分发的，也就是我们会有以下的一些 GraphQL API 服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://draveness.me/posts/api/graphql</span><br><span class="line">https://draveness.me/comments/api/graphql</span><br><span class="line">https://draveness.me/subscriptions/api/graphql</span><br></pre></td></tr></table></figure>
<p>但这种设计其实并没有充分利用 GraphQL 服务的优点，当客户端或前端同时需要多个服务的资源时，需要分别请求不同服务上的资源，并不能通过一次 HTTP 请求满足全部的需求。</p>
<p>另一种方式其实提供了一种集中式的接口，所有的微服务对外共同暴露一个端点，根据请求中不同的字段进行路由。</p>
<p><img src="/images/post/graphql/136673448.png" alt="graphql"></p>
<p>这种方式是按照 field 进行路由的，而 GraphQL 已经帮助我们完成了解析的过程，我们只需要对相应字段实现特定的 Resolver 处理返回的逻辑就可以。<br>在实践中，作为一门中心化的查询语言，GraphQL 在最佳实践中应该只对外暴露一个端点，并且这个端点包含当前 Web 服务应该提供的全部资源，并把它们合理的连接成图，因此第二种方式更加合理。</p>
<p>然而这种方式，需要思考如何解决在整合 Schema 的过程中服务之间的重复资源和冲突字段问题，需要找到一种机制将多个服务的 Schema 完美整合起来。</p>
<p>目前业界主要有以下解决方式：<br>1）前缀<br>为多个服务提供的资源添加命名空间，一般来说就是前缀，在合并 Schema 时，通过添加前缀能够避免不同服务出现重复字段造成冲突的可能。</p>
<p><img src="/images/post/graphql/128198702.png" alt="graphql"></p>
<p>感兴趣的可以阅读 GraphQL at massive scale: GraphQL as the glue in a microservice architecture 了解这种做法的实现细节。这种增加前缀解决冲突的方式优点就是开发成本非常低，但是它将各个微服务的资源看成是一个个的孤岛，资源相互之间没有办法建立关系，串联起来。</p>
<p>2）粘合<br>GraphQL 官方提供了一种名为 Schema Stitching 的方案，能够将不同服务的 GraphQL Schema 粘合起来并对外暴露统一的接口，这种方式能够将多个服务中的不同资源粘合起来，能够充分利用 GraphQL 的优势。</p>
<p><img src="/images/post/graphql/128260354.png" alt="graphql"></p>
<p>这种方式，需要我们在上层完成对公共资源的处理。当整个 Schema 进行合并时，如果遇到公共资源，就会选用特定的 Resolver 进行解析，而这些解析器的逻辑是在 Schema Stitching 时指定的。</p>
<p>官方提供了一个实现方式，就是通过方法 mergeSchemas ，其详情可以参看 <a href="https://www.apollographql.com/docs/apollo-server/api/graphql-tools.html#mergeSchemas" target="_blank" rel="noopener">https://www.apollographql.com/docs/apollo-server/api/graphql-tools.html#mergeSchemas</a> 。<br>方法 mergeSchemas 接受三个参数，需要粘合的 Schema 数组、多个 Resolver 以及类型出现冲突时的回调：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mergeSchemas(&#123;</span><br><span class="line">  schemas: <span class="built_in">Array</span>&lt;string | GraphQLSchema | <span class="built_in">Array</span>&lt;GraphQLNamedType&gt;&gt;;</span><br><span class="line">  resolvers?: <span class="built_in">Array</span>&lt;IResolvers&gt; | IResolvers;</span><br><span class="line">  onTypeConflict?: (</span><br><span class="line">    left: GraphQLNamedType,</span><br><span class="line">    right: GraphQLNamedType,</span><br><span class="line">    info?: &#123;</span><br><span class="line">      left: &#123;</span><br><span class="line">        schema?: GraphQLSchema;</span><br><span class="line">      &#125;;</span><br><span class="line">      right: &#123;</span><br><span class="line">        schema?: GraphQLSchema;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  ) =&gt; GraphQLNamedType;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>我们团队在实践中，项目主要是通过 Koa + Apollo Server + Dataloader + RPC 进行搭建。</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>项目的目录结构如下，其中</p>
<ul>
<li>graphql：存放所有graphql文件</li>
<li>common：存放通用的schema、directive</li>
<li>schema：业务逻辑（各业务模块：每个业务模块包含一个resolver.js和schema.graphql文件）</li>
<li>service：后端RPC服务，使用dataloader封装后端RPC服务，提供统一服务</li>
<li>util：工具类</li>
<li>index.js：聚合所有schema文件</li>
</ul>
<p><img src="/images/post/graphql/144971891.png" alt="graphql"></p>
<h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>为了减小重复代码，schema可以按照模块化的方式进行划分，可抽离公共的schema，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"分页信息"</span></span><br><span class="line">type PageInfo &#123;</span><br><span class="line">    <span class="string">"当前页数"</span></span><br><span class="line">    currentPageNum: Int!</span><br><span class="line">    <span class="string">"每页显示数量"</span></span><br><span class="line">    pageSize: Int!</span><br><span class="line">    <span class="string">"总页数"</span></span><br><span class="line">    totalPageCount: Int!</span><br><span class="line">    <span class="string">"总条数"</span></span><br><span class="line">    totalCount: Int!</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="string">"错误"</span></span><br><span class="line">type <span class="built_in">Error</span> &#123;</span><br><span class="line">    <span class="string">"错误码"</span></span><br><span class="line">    code: Int!</span><br><span class="line">    <span class="string">"错误信息"</span></span><br><span class="line">    msg: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在业务 schema 需要使用公共 schema的时候，通过 import 的方式进行引入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">\# import PageInfo from "../common/schema.graphql"</span><br><span class="line">​</span><br><span class="line">type Hero &#123;</span><br><span class="line">  power: Int!</span><br><span class="line">  name: <span class="built_in">String</span>!</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">type HeroPage &#123;</span><br><span class="line">    pageInfo: PageInfo!</span><br><span class="line">    data: [Hero]</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">type Query &#123;</span><br><span class="line">    allHeros: HeroPage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后可通过以下方式进行集成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; makeExecutableSchema &#125; = <span class="built_in">require</span>(<span class="string">'graphql-tools'</span>);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> typeDefs = importSchema(<span class="string">'hero.graphql'</span>);</span><br><span class="line"><span class="keyword">const</span> schema = makeExecutableSchema(&#123;</span><br><span class="line">    typeDefs,</span><br><span class="line">    resolvers,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="数据请求"><a href="#数据请求" class="headerlink" title="数据请求"></a>数据请求</h3><p>强烈建议通过RPC服务调用后端接口，而不是http服务，以减少请求的耗时。</p>
<h3 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h3><p>身份鉴权，有两种方式：全局和局部</p>
<h4 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h4><p>在入口处，也即 context 回调中，进行全局的鉴权</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; ApolloServer, AuthenticationError &#125; = <span class="built_in">require</span>(<span class="string">'apollo-server-koa'</span>);</span><br><span class="line">​</span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> ApolloServer(&#123;</span><br><span class="line">    schema,</span><br><span class="line">    context: <span class="keyword">async</span> (&#123; ctx &#125;) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 为每次会话创建loader</span></span><br><span class="line">        <span class="keyword">const</span> loaders = createLoaders(ctx);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行身份校验等前置操作</span></span><br><span class="line">        <span class="keyword">let</span> user = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            user = <span class="keyword">await</span> authorize(ctx, loaders);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            ctx.logcenter.error(<span class="string">'Pigeon'</span>, <span class="string">'authorizeRequest'</span>, e.message);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationError(<span class="string">'You are not authorized!'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            user,</span><br><span class="line">            loaders,</span><br><span class="line">            env,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    debug: env !== <span class="string">'product'</span>,</span><br><span class="line">&#125;);</span><br><span class="line">server.applyMiddleware(&#123; app &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="局部"><a href="#局部" class="headerlink" title="局部"></a>局部</h4><p>如果要实现局部鉴权（个别字段才需要鉴权），可以通过directive来控制<br>1）创建一个鉴权的directive，可参考以下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SchemaDirectiveVisitor &#125; = <span class="built_in">require</span>(<span class="string">'graphql-tools'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; defaultFieldResolver &#125; = <span class="built_in">require</span>(<span class="string">'graphql'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; AuthenticationError &#125; = <span class="built_in">require</span>(<span class="string">'apollo-server-koa'</span>);</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthDirective</span> <span class="keyword">extends</span> <span class="title">SchemaDirectiveVisitor</span> </span>&#123;</span><br><span class="line">    visitObject(type) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ensureFieldsWrapped(type);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    visitFieldDefinition(field, details) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ensureFieldsWrapped(details.objectType);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    ensureFieldsWrapped(objectType) &#123;</span><br><span class="line">        <span class="comment">// Mark the GraphQLObjectType object to avoid re-wrapping:</span></span><br><span class="line">        <span class="keyword">if</span> (objectType._authFieldsWrapped) <span class="keyword">return</span>;</span><br><span class="line">        objectType._authFieldsWrapped = <span class="literal">true</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">const</span> fields = objectType.getFields();</span><br><span class="line">​</span><br><span class="line">        <span class="built_in">Object</span>.keys(fields).forEach(<span class="function"><span class="params">fieldName</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> field = fields[fieldName];</span><br><span class="line">            <span class="keyword">const</span> &#123; resolve = defaultFieldResolver &#125; = field;</span><br><span class="line">            field.resolve = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">const</span> context = args[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">const</span> &#123; user &#125; = context;</span><br><span class="line">                <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationError(<span class="string">'You are not authorized!'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">​</span><br><span class="line">                <span class="keyword">return</span> resolve.apply(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="built_in">module</span>.exports = AuthDirective;</span><br></pre></td></tr></table></figure>
<p>2）在schema中，需要鉴权的字段进行引用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">directive @auth on FIELD_DEFINITION</span><br><span class="line">​</span><br><span class="line"><span class="string">"角色数据"</span></span><br><span class="line">type Role &#123;</span><br><span class="line">    <span class="string">"角色id"</span></span><br><span class="line">    roleId: Int</span><br><span class="line">    <span class="string">"角色名称"</span></span><br><span class="line">    roleName: <span class="built_in">String</span></span><br><span class="line">    <span class="string">"角色状态"</span></span><br><span class="line">    status: Int</span><br><span class="line">    <span class="string">"授权列表"</span></span><br><span class="line">    permissionIdList: [Int]</span><br><span class="line">    <span class="string">"适用门店"</span></span><br><span class="line">    adaptShopType: Int</span><br><span class="line">    <span class="string">"APP操作模式"</span></span><br><span class="line">    appApplyMode: Int</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">type Query &#123;</span><br><span class="line">    role(</span><br><span class="line">        <span class="string">"角色id"</span></span><br><span class="line">        roleID: Int!</span><br><span class="line">    ): Role @auth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​<br>3）在 makeExecutableSchema 时，添加 schemaDirectives ，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = makeExecutableSchema(&#123;</span><br><span class="line">      typeDefs,</span><br><span class="line">      resolvers,</span><br><span class="line">      schemaDirectives: &#123;</span><br><span class="line">          auth: AuthDirective,</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>Apollo Server集成了graphiql，可以很方便的测试接口，所见即所得，而且可以随时展开右侧的API文档，即时查阅所有的接口，包括参数信息和返回数据，一目了然。</p>
<p><img src="/images/post/graphql/134899495.png" alt="graphql"></p>
<p><img src="/images/post/graphql/134914845.png" alt="graphql"></p>
<p>在我们项目中，我们挑选了一个页面进行重构。这个页面加载的时候会重复调用某几个接口，并且只是不同的参数组合，而且需要等待这些接口都返回之后才可以正常展示</p>
<p><img src="/images/post/graphql/134897956.png" alt="graphql"></p>
<p>而且原先返回的数据结构，基本是后端的数据模型，返回了很多前端不会用到的字段，非常冗余。</p>
<p><img src="/images/post/graphql/135033258.png" alt="graphql"></p>
<p>然后我们进行了重构，将这些RESTfull接口通过 GraphQL 进行集成，只需要通过一次请求，就完成了上述七个接口的工作</p>
<p><img src="/images/post/graphql/134950238.png" alt="graphql"></p>
<p>并且只会返回前端需要的字段，再也没有冗余字段。</p>
<p><img src="/images/post/graphql/135033459.png" alt="graphql"></p>
<p>集成了七个 RESTfull 接口功能的单个 GraphQL 请求的耗时，只比单个 RESTfull 请求的多了几十毫秒。</p>
<p><img src="/images/post/graphql/134924789.png" alt="graphql"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>GraphQL可以将多个网络请求接口合并成一个，非常适合于单个页面需要调用多个 RESTfull 接口的场景，比如财务报表页面；</p>
<p>GraphQL由于只提供单个对外接口，调用方如果聚合的接口越多，耗时会增加的越多，需要考虑好粒度，可以通过dataloader进行优化，但无法彻底解决性能问题；</p>
<p>Schema的设计需要谨慎，避免节点冲突和Schema结构混乱，以及产生性能问题；</p>
<p>GraphQL是一个集中式的管理，如果业务系统强依赖的话，需要考虑如何解决单点故障，建议GraphQL只做分发，尽量轻薄；</p>
<p>GraphQL虽然提供 mutation 类型来支持修改数据，但从语法的支持上还是比较古怪，且使用场景上并发多个Post请求的操作也比较少见，个人感觉更适合于查询的场景。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://cloud.tencent.com/developer/article/1354447" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1354447</a><br><a href="http://jerryzou.com/posts/10-questions-about-graphql/" target="_blank" rel="noopener">http://jerryzou.com/posts/10-questions-about-graphql/</a><br><a href="https://ithelp.ithome.com.tw/articles/10200678?sc=hot" target="_blank" rel="noopener">https://ithelp.ithome.com.tw/articles/10200678?sc=hot</a><br><a href="https://draveness.me/graphql-microservice" target="_blank" rel="noopener">https://draveness.me/graphql-microservice</a></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/23/bff/" rel="next" title="Backend for frontend">
                <i class="fa fa-chevron-left"></i> Backend for frontend
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/16/swimlane/" rel="prev" title="Swimlane">
                Swimlane <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/default_avatar.png" alt="Justin Yang">
            
              <p class="site-author-name" itemprop="name">Justin Yang</p>
              <div class="site-description motion-element" itemprop="description">Blog and website of Justin Yang, blogging mainly for tech. Opinions expressed are mine.</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/yang2012" title="GitHub &rarr; https://github.com/yang2012" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:justin.yang2012@gmail.com" title="E-Mail &rarr; mailto:justin.yang2012@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://twitter.com/justinyang09" title="Twitter &rarr; https://twitter.com/justinyang09" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.facebook.com/justinyang2012" title="FB Page &rarr; https://www.facebook.com/justinyang2012" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i>FB Page</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#导读"><span class="nav-number">1.</span> <span class="nav-text">导读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#背景"><span class="nav-number">2.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">3.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对比"><span class="nav-number">4.</span> <span class="nav-text">对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优点"><span class="nav-number">4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不足"><span class="nav-number">4.2.</span> <span class="nav-text">不足</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用"><span class="nav-number">5.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实践"><span class="nav-number">6.</span> <span class="nav-text">实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目录结构"><span class="nav-number">6.1.</span> <span class="nav-text">目录结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Schema"><span class="nav-number">6.2.</span> <span class="nav-text">Schema</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据请求"><span class="nav-number">6.3.</span> <span class="nav-text">数据请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#鉴权"><span class="nav-number">6.4.</span> <span class="nav-text">鉴权</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局"><span class="nav-number">6.4.1.</span> <span class="nav-text">全局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部"><span class="nav-number">6.4.2.</span> <span class="nav-text">局部</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#效果展示"><span class="nav-number">7.</span> <span class="nav-text">效果展示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">9.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2013 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Justin Yang</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
