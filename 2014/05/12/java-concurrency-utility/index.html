<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  

<script type="text/javascript">
    var host = "justinyangis.me";
    if ((host == window.location.host) && (window.location.protocol != "https:"))
        window.location.protocol = "https";
</script>

  <meta name="description" content="这篇博文是Java Concurrency系列博文的第二篇。在这篇博文，我们将会来共同探索Java多线程编程中常用到的机制，包括Latch、Barrier、Future和Semaphore。 PS：本文主要参考了Java Concurrentcy in Pratice一书，如有纰漏，请谅解。 java.util.concurrent.atomicAtomicBoolean">
<meta name="keywords" content="justin, yang, yijie yang, iOS, Web, front-end">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Concurrency - Utility">
<meta property="og:url" content="https://www.justinyangis.me/2014/05/12/java-concurrency-utility/index.html">
<meta property="og:site_name" content="Justin Yang">
<meta property="og:description" content="这篇博文是Java Concurrency系列博文的第二篇。在这篇博文，我们将会来共同探索Java多线程编程中常用到的机制，包括Latch、Barrier、Future和Semaphore。 PS：本文主要参考了Java Concurrentcy in Pratice一书，如有纰漏，请谅解。 java.util.concurrent.atomicAtomicBoolean">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-23T10:32:23.276Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Concurrency - Utility">
<meta name="twitter:description" content="这篇博文是Java Concurrency系列博文的第二篇。在这篇博文，我们将会来共同探索Java多线程编程中常用到的机制，包括Latch、Barrier、Future和Semaphore。 PS：本文主要参考了Java Concurrentcy in Pratice一书，如有纰漏，请谅解。 java.util.concurrent.atomicAtomicBoolean">





  
  
  <link rel="canonical" href="https://www.justinyangis.me/2014/05/12/java-concurrency-utility/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java Concurrency - Utility | Justin Yang</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Justin Yang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">hello world</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.justinyangis.me/2014/05/12/java-concurrency-utility/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Justin Yang">
      <meta itemprop="description" content="Blog and website of Justin Yang, blogging mainly for tech. Opinions expressed are mine.">
      <meta itemprop="image" content="/images/default_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Justin Yang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java Concurrency - Utility

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2014-05-12 00:00:00" itemprop="dateCreated datePublished" datetime="2014-05-12T00:00:00+08:00">2014-05-12</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这篇博文是Java Concurrency系列博文的第二篇。在这篇博文，我们将会来共同探索Java多线程编程中常用到的机制，包括Latch、Barrier、Future和Semaphore。</p>
<p>PS：本文主要参考了Java Concurrentcy in Pratice一书，如有纰漏，请谅解。</p>
<h2 id="java-util-concurrent-atomic"><a href="#java-util-concurrent-atomic" class="headerlink" title="java.util.concurrent.atomic"></a>java.util.concurrent.atomic</h2><pre><code>AtomicBoolean                        - 可原子更新的布尔变量
AtomicInteger                        - 可原子更新的int变量
AtomicIntegerArray                    - int数组，包含的元素都是可原子更新的
AtomicIntegerFieldUpdater&lt;T&gt;        - 基于反射的实用工具，可以对指定类的指定volatile int字段进行原子更新
AtomicLong                            - 可原子更新的long变量
AtomicLongArray                        - long数组，包含的元素都是可原子更新的
AtomicLongFieldUpdater&lt;T&gt;            - 基于反射的实用工具，可以对指定类的指定volatile long字段进行原子更新。用于原子数据结构，该结构中同一节点的几个字段都独立受原子更新控制。
AtomicMarkableReference&lt;V&gt;            - 将对象引用关联一个标记比特，可原子更新
AtomicReference&lt;V&gt;                    - 可原子更新的对象引用
AtomicReferenceArray&lt;E&gt;                - 对象引用数组，包含的元素都是可原子更新的
AtomicReferenceFieldUpdate&lt;T, V&gt;    - 基于反射的实用工具，可以对指定类的指定volatile引用字段进行原子更新
AtomicStampedReference&lt;V&gt;            - 将对象引用关联一个integer“标签”，可原子更新
</code></pre><p>java.util.concurrent.atomic包所提供的类，不基于锁机制，实现单一变量的线程安全。这个包中的类，在volatile变量、属性和数组元素的基础上，增加了原子条件更新操作：<code>boolean compareAndSet(expectedValue, updateValue);</code>。这个方法可以原子更新某个变量。如果这个变量当前的值是<code>expectedValue</code>，就会将一个变量设置为<code>updateValue</code>。如果成功更新，则会返回<code>true</code>。这个包中的类同样提供了一些获取和非条件设置变量方法，以及弱条件原子更新操作<code>weakComparedAndSet</code>。</p>
<a id="more"></a>
<p>这些方法的规范，让实现可以采用当代处理器的高效机器级别原子操作指令，来实现原子操作。但是在一些平台，可能会需要使用到内部锁机制。因此这些方法严格上来说，并不都是非阻塞的 - 一个线程在执行这些操作的时候可能会被隐形地被阻塞。</p>
<p><code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>和<code>AtomicReference</code>的示例各自提供相应类型的变量的访问和更新操作，以及其他一些实用工具的原子操作。比如，<code>AtomicLong</code>和<code>AtomicInteger</code>提供了原子增量方法。比如：</p>
<pre><code>class Sequencer {
    private final AtomicLong sequenceNumber = new AtomicLong(0);
    public long next() {
        return sequenceNumber.getAndIncrement();
    }
}
</code></pre><p>原子变量获取和更新的内存效果，总体上遵循<code>volatile</code>的规则：</p>
<ul>
<li><code>get</code>跟读取<code>volatile</code>变量的内存效果一样；</li>
<li><code>set</code>跟写入（赋值）<code>volatile</code>变量的内存效果一样；</li>
<li><code>lazySet</code>，跟写入（赋值）<code>volatile</code>变量的内存效果一样，除了它允许后续的内存操作进行重排（专指那些自身没有对一般non-volatile变量的写操作的有重排约束的操作）；</li>
<li><code>weakCompareAndSet</code>以原子方式读取和条件写入某个变量，可能发生意外失败，并且不提供排序保证，但对于字段中的其他更改不一定确保原子性；</li>
<li><code>compareAndSet</code>和其他读取-然后-写入的操作，比如<code>getAndIncrement</code>，跟读取和写入<code>volatile</code>变量的内存效果一样。</li>
</ul>
<figure class="highlight plain"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Atomically sets the value to the given updated value</span><br><span class="line"> * if the current value &#123;@code ==&#125; the expected value.</span><br><span class="line"> *</span><br><span class="line"> * @param expect the expected value</span><br><span class="line"> * @param update the new value</span><br><span class="line"> * @return true if successful. False return indicates that</span><br><span class="line"> * the actual value was not equal to the expected value.</span><br><span class="line"> */</span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Atomically sets the value to the given updated value</span><br><span class="line"> * if the current value &#123;@code ==&#125; the expected value.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;May &lt;a href=&quot;package-summary.html#Spurious&quot;&gt;fail spuriously&lt;/a&gt;</span><br><span class="line"> * and does not provide ordering guarantees, so is only rarely an</span><br><span class="line"> * appropriate alternative to &#123;@code compareAndSet&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param expect the expected value</span><br><span class="line"> * @param update the new value</span><br><span class="line"> * @return true if successful.</span><br><span class="line"> */</span><br><span class="line">public final boolean weakCompareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是java 1.7的实现代码，从中我们可以看到<code>compareAndSet</code>和<code>weakCompareAndSet</code>的实现其实是一样的。但是从注释中，我们可以看到，<code>weakCompareAndSet</code>可能会发生意外失败，只有在很少的情况下才适合来替代<code>compareAndSet</code>。虽然目前的实现是一样的，但这可能是暂时的，将来可能会不一样，所以在使用的时候，我们还是应该按照接口说明来使用。</p>
<p>除了包含表示单个值的类之外，此包还包含 Updater 类，该类可用于获取任意选定类的任意选定<code>volatile</code>字段上的<code>compareAndSet</code>操作。<code>AtomicReferenceFieldUpdater</code>、<code>AtomicIntegerFieldUpdater</code>和 <code>AtomicLongFieldUpdater</code>是基于反射的实用工具，可以提供对关联字段类型的访问。它们主要用于原子数据结构中，该结构中同一节点（例如，树节点的链接）的几个 volatile 字段都独立受原子更新控制。这些类在如何以及何时使用原子更新方面具有更大的灵活性，但相应的弊端是基于映射的设置较为拙笨、使用不太方便，而且在保证方面也较差。</p>
<p><code>AtomicMarkableReference</code>类将单个布尔值与引用关联起来。例如，可以在数据结构内部使用此位，来标记引用的对象在逻辑上已被删除。AtomicStampedReference类将整数值与引用关联起来。例如，这可用于表示与更新系列对应的版本号。</p>
<p>Atomic类不能完全用来替代<code>java.lang.Integer</code>等相关类。Atomic类并不提供诸如<code>hashCode</code>和<code>compareTo</code>等方法。因为atomic变量是可变的，不适合用来当做哈希表的键值。另外，Atomic类仅提供常用的类型。例如，没有表示 byte 的原子类。如果需要这么做，可以使用<code>AtomicInteger</code>来保持byte值，然后再进行适当的强制转换。</p>
<figure class="highlight plain"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 6214790243416807050L;</span><br><span class="line"></span><br><span class="line">    // setup to use Unsafe.compareAndSwapInt for updates</span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">      &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile int value;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new AtomicInteger with the given initial value.</span><br><span class="line">     *</span><br><span class="line">     * @param initialValue the initial value</span><br><span class="line">     */</span><br><span class="line">    public AtomicInteger(int initialValue) &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    /**</span><br><span class="line">     * Atomically increments by one the current value.</span><br><span class="line">     *</span><br><span class="line">     * @return the previous value</span><br><span class="line">     */</span><br><span class="line">    public final int getAndIncrement() &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int current = get();</span><br><span class="line">            int next = current + 1;</span><br><span class="line">            if (compareAndSet(current, next))</span><br><span class="line">                return current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    /**</span><br><span class="line">     * Atomically sets the value to the given updated value</span><br><span class="line">     * if the current value &#123;@code ==&#125; the expected value.</span><br><span class="line">     *</span><br><span class="line">     * @param expect the expected value</span><br><span class="line">     * @param update the new value</span><br><span class="line">     * @return true if successful. False return indicates that</span><br><span class="line">     * the actual value was not equal to the expected value.</span><br><span class="line">     */</span><br><span class="line">    public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从<code>AtomicInteger</code>的实现代码，可以看到<code>AtomicInteger</code>类只有三个属性<code>unsafe</code>，<code>valueOffset</code>和<code>value</code>.其中，<code>unsafe</code>是java提供的获得对对象内存地址访问的类，注释已经清楚的写出了，它的作用就是在更新操作时提供“比较并替换”的作用。实际上就是<code>AtomicInteger</code>中的一个工具类。<code>valueOffset</code>是用来记录<code>value</code>本身在内存的偏移地址的，主要是为了在更新操作的时候方便在内存中找到<code>value</code>的位置。<code>value</code>是用来存储整数的时间变量，这里被声明为<code>volatile</code>，就是为了保证在更新操作时，当前线程可以拿到<code>value</code>最新的值。</p>
<p>为了更好地理解<code>AtomicInteger</code>的内部机理，我们来看一下方法<code>getAndIncrement</code>的实现。这个方法中主要是调用了方法<code>compareAndSet</code>，而<code>compareAndSet</code>则是调用了<code>unsafe</code>的<code>compareAndSwapInt</code>方法，也即使用unsafe的native方法，从而实现高效的硬件级别原子操作。所以，<code>AtomicInteger</code>的秘密就在于<code>Unsafe</code>。</p>
<p>通过上面的源代码，我们知道<code>AtomicInteger</code>是通过<code>Unsafe.getUnsafe();</code>方法来初始化<code>unsafe</code>。在一般情况下，我们是拿不到该类的实例的，当然jdk库里面是可以随意使用的。</p>
<pre><code>static {
      try {
        valueOffset = unsafe.objectFieldOffset
            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
      } catch (Exception ex) { throw new Error(ex); }
}
</code></pre><p>上面的这个静态代码块是用来获取<code>AtomicInteger</code>实例中的<code>value</code>属性在内存中的位置<code>valueOffset</code>。这里使用了<code>Unsafe</code>的<code>objectFieldOffset</code>方法。这个方法是<code>unsafe</code>的<code>native</code>方法，用来获取一个给定的静态属性的位置。</p>
<p>在<code>AtomicInteger</code>中的多个地方都使用到了<code>valueOffset</code>，比如<code>compareAndSet</code>：</p>
<pre><code>public final boolean compareAndSet(int expect, int update) {
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
</code></pre><p>这里，如果<code>valueOffset</code>位置包含的值与<code>expect</code>值相同，则更新<code>valueOffset</code>位置的值为<code>update</code>，并返回<code>true</code>，否则不更新，返回<code>false</code>。</p>
<p>关于<code>Unsafe</code>的<code>compareAndSwapInt</code>方法的具体实现，感兴趣的读者可以自行去这里<a href="http://www.docjar.com/html/api/sun/misc/Unsafe.java.html" target="_blank" rel="noopener">http://www.docjar.com/html/api/sun/misc/Unsafe.java.html</a>进行了解，这里就不再详细分析。</p>
<hr>
<h2 id="Latch"><a href="#Latch" class="headerlink" title="Latch"></a>Latch</h2><p><code>Latch</code>相当于一个大门。在<code>Latch</code>到达终止的状态之前，大门都是关闭的，此时所有线程都会被阻塞。只有latch到达了终止状态，大门才会打开，然后线程才能通过。一旦<code>Latch</code>达到终止状态，<code>Latch</code>是不能再改变状态，会一直保持打开。</p>
<p><code>Latch</code>常用来确保在其他一次性的活动完成之前，阻止特定的活动继续执行。比如说：</p>
<ul>
<li>在所需的资源没有准备好之前，某个计算任务不能提前执行。一个只有两个状态的<code>Latch</code>可以用来表示“资源是否已经准备好”。</li>
<li>在一个任务所依赖的其他任务没有开始之前，这个任务不能提前开始。每一个任务都与一个二值<code>Latch</code>相关联。在开始某一项任务之前，首先等待其所依赖的其他任务的<code>Latch</code>。然后在任务结束之后，释放这个任务关联的<code>Latch</code>，以便让依赖与这个任务的其他任务可以继续执行。</li>
</ul>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p><code>CountDownLatch</code>是<code>Latch</code>的一个实现，允许一个或者多个线程等待一组事件发生。<code>CountDownLatch</code>的内部维护了一个计数器。初始化<code>CountDownLatch</code>时需要指定计数器的初始值，用来表示需要等待完成的事件的个数。每调用一次<code>countDown</code>方法，表示其中一个事件已经完成，计数器的值将减一。如果计数器没有为0，那调用<code>wait</code>方法的所有的线程都会被阻塞，直到计数器减为0（也即所有的事件都发生了），线程被中断，或者等待超时。</p>
<figure class="highlight plain"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class TestHarness &#123;</span><br><span class="line">	public long timeTasks(int nThreads, final Runnable task)</span><br><span class="line">	throws InterruptedException &#123;</span><br><span class="line">		final CountDownLatch startGate = new CountDownLatch(1);</span><br><span class="line">		final CountDownLatch endGate = new CountDownLatch(nThreads);</span><br><span class="line">		for (int i = 0; i &lt; nThreads; i++) &#123; </span><br><span class="line">			Thread t = new Thread() &#123;</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						startGate.await(); </span><br><span class="line">						try &#123;</span><br><span class="line">							task.run(); </span><br><span class="line">						&#125; finally &#123;</span><br><span class="line">							endGate.countDown(); </span><br><span class="line">						&#125;</span><br><span class="line">					&#125; catch (InterruptedException ignored) &#123; &#125; </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		long start = System.nanoTime();</span><br><span class="line">		startGate.countDown();</span><br><span class="line">		endGate.await();</span><br><span class="line">		long end = System.nanoTime();</span><br><span class="line">		return end-start;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><p><code>Latch</code>就像是一次性筷子，只能用一次，一旦到达终止状态，就不能再改变，不能重复使用。但我们很多时候是要重复同样的动作，这个时候就需要使用<code>Barrier</code>。与<code>Latch</code>相似，<code>Barrier</code>同样可以阻塞线程，直到特定的事件发生。它们的区别就在于<code>Barrier</code>所有的线程都必须都达到某个屏障点才可以继续运行，也就是说<code>Barrier</code>等待的是线程，而<code>Latch</code>等待的是事件。就比如说，你要参加同学聚会，然后收到一封邮件，里面写着“大家明天6点在麦当劳那里等，如果你先到，那你就在那里等其他人，直到所有人都到了之后，我们再来商量去哪里玩。”，这就是<code>Barrier</code>。</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p><code>CyclicBarrier</code>允许一组线程互相等待，直到该组线程全部到达某个屏障点。在创建<code>CyclicBarrier</code>的时候，需要指定线程组中线程的数量。调用<code>CyclicBarrier</code>对象的<code>await</code>方法，表示当前线程已到达屏障点，然后等待其他线程到达。当所有线程到达公共屏障点后，<code>CyclicBarrier</code>对象将打开，释放线程组，然后重置<code>CyclicBarrier</code>对象的状态。因此<code>CyclicBarrier</code>是可以循环使用的。如果有线程在等待期间超时或者被中断, 该<code>CyclicBarrier</code>对象被视为已损坏，随后对<code>await</code>方法的调用都要抛出<code>BrokenBarrierException</code>异常。</p>
<figure class="highlight plain"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class CellularAutomata &#123;</span><br><span class="line">	private final Board mainBoard;</span><br><span class="line">	private final CyclicBarrier barrier;</span><br><span class="line">	private final Worker[] workers;</span><br><span class="line">	</span><br><span class="line">	public CellularAutomata(Board board) &#123;</span><br><span class="line">		this.mainBoard = board;</span><br><span class="line">		int count = Runtime.getRuntime().availableProcessors();</span><br><span class="line">		this.barrier = new CyclicBarrier(count,</span><br><span class="line">			new Runnable() &#123;</span><br><span class="line">				public void run() &#123;</span><br><span class="line">					mainBoard.commitNewValues();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		this.workers = new Worker[count]; </span><br><span class="line">		for (int i = 0; i &lt; count; i++)</span><br><span class="line">			workers[i] = new Worker(mainBoard.getSubBoard(count, i));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private class Worker implements Runnable &#123;</span><br><span class="line">		private final Board board;</span><br><span class="line">		</span><br><span class="line">		public Worker(Board board) &#123;this.board = board; &#125; </span><br><span class="line">		public void run() &#123;</span><br><span class="line">			while (!board.hasConverged()) &#123;</span><br><span class="line">				for (int x = 0; x &lt; board.getMaxX(); x++)</span><br><span class="line">					for (int y = 0; y &lt; board.getMaxY(); y++)</span><br><span class="line">						board.setNewValue(x, y, computeValue(x, y));</span><br><span class="line">				try &#123;</span><br><span class="line">					barrier.await();</span><br><span class="line">				&#125; catch (InterruptedException ex) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125; catch (BrokenBarrierException ex) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		for (int i = 0; i &lt; workers.length; i++)</span><br><span class="line">			new Thread(workers[i]).start();</span><br><span class="line">		mainBoard.waitForConvergence();&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>Exchanger，是另外一种Barrier，可以用来完成线程间的数据交换。</p>
<p>Exchanger非常适合用于两个异步线程之间交换数据。比如说，有两个线程，一个负责往缓冲填数据，一个负责从缓冲取数据，那么这两个线程就可以通过Exchanger来交换数据。每个线程都在调用<code>exchange</code>方法时给出某个对象，并接受其他线程返回时给出的对象。两个线程通过Exchanger来交换的信息（也就对象），对于两个线程来说都是线程安全的。</p>
<hr>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p><code>FutureTask</code>实现了<code>Future</code>接口，常用来获得某个计算任务的结果。</p>
<p>FutureTask常用的构造函数为FutureTask(Callable<v> callable)，使用Callable封装任务，而不是Runnable（对于Callable和Runnable的区别，请参看<a href="#calAndRun">这里</a>）。FutureTask对象具有三种状态: 等待运行，正在运行，已完成。不管是计算完成，抛出异常或者被取消，都会使得FutureTask的状态变为已完成。一旦<code>FutureTask</code>进入完成状态，那它就会一直保持这个状态，也就是<code>FutureTask</code>是不可以重用的。</v></p>
<p>通过FutureTask的get方法可以返回任务的执行结果。如果FutureTask对象处于已完成状态，那get方法将立即返回计算结果，否则get方法会阻塞，直到FutureTask转变为已完成状态。</p>
<p>FutureTask的常见使用场景是封装一个耗时任务，然后提前开始计算，当需要计算结果时，再调用其get方法，这样可以减少等待计算完成的时间。</p>
<figure class="highlight plain"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Preloader &#123;</span><br><span class="line">	private final FutureTask&lt;ProductInfo&gt; future =</span><br><span class="line">		new FutureTask&lt;ProductInfo&gt;(new Callable&lt;ProductInfo&gt;() &#123;</span><br><span class="line">			public ProductInfo call() throws DataLoadException &#123;</span><br><span class="line">				return loadProductInfo(); </span><br><span class="line">			&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	private final Thread thread = new Thread(future);</span><br><span class="line">	</span><br><span class="line">	public void start() &#123; thread.start(); &#125;</span><br><span class="line">	</span><br><span class="line">	public ProductInfo get()</span><br><span class="line">	throws DataLoadException, InterruptedException &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return future.get();</span><br><span class="line">		&#125; catch (ExecutionException e) &#123;</span><br><span class="line">			Throwable cause = e.getCause();</span><br><span class="line">			if (cause instanceof DataLoadException)</span><br><span class="line">				throw (DataLoadException) cause;</span><br><span class="line">			else</span><br><span class="line">				throw launderThrowable(cause);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>Semaphore</code>用于管理许可。在创建<code>Semaphore</code>对象的时候，需要指定许可的最大个数。线程首先通过<code>acquare</code>方法来申请获得许可（如果有的话），然后在完成之后再调用<code>release</code>方法来释放许可。要是当前<code>Semaphore</code>已经没有可用的许可，那申请的线程就会被阻塞，直到有可用的许可（或者直到被中断或者超时）。许可是不与线程绑定的，一个线程申请的许可，可以在另一个线程里释放。</p>
<p><code>Semaphore</code>通常用于实现资源池，如数据库连接池等。另外，<code>Semaphore</code>也可以用于将任何集合变成阻塞式的有界集合。</p>
<p>特别的是，当许可的数量为一时，<code>Semaphore</code>就可当做互斥锁来使用，可用来实现非重入的锁机制。</p>
<figure class="highlight plain"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class BoundedHashSet&lt;T&gt; &#123; private final Set&lt;T&gt; set;</span><br><span class="line">	private final Semaphore sem;</span><br><span class="line">	public BoundedHashSet(int bound) &#123;</span><br><span class="line">		this.set = Collections.synchronizedSet(new HashSet&lt;T&gt;());</span><br><span class="line">		sem = new Semaphore(bound);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean add(T o) throws InterruptedException &#123; </span><br><span class="line">		sem.acquire();</span><br><span class="line">		boolean wasAdded = false;</span><br><span class="line">		try &#123;</span><br><span class="line">			wasAdded = set.add(o);</span><br><span class="line">			return wasAdded;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			if (!wasAdded)</span><br><span class="line">				sem.release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public boolean remove(Object o) &#123;</span><br><span class="line">		boolean wasRemoved = set.remove(o);</span><br><span class="line">		if (wasRemoved)</span><br><span class="line">			sem.release();</span><br><span class="line">		return wasRemoved;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Callable-amp-Runnable"><a href="#Callable-amp-Runnable" class="headerlink" title="Callable &amp; Runnable"></a>Callable &amp; Runnable</h3><p><div id="calAndRun"></div><code>Callable</code>接口和<code>Runnable</code>接口相似，都是接口，区别就是<code>Callable</code>需要实现<code>call</code>方法，而<code>Runnable</code>需要实现<code>run</code>方法；并且，<code>call</code>方法还可以返回任何对象，无论是什么对象，JVM都会当作<code>Object</code>来处理。但是如果使用了泛型，我们就不用每次都对<code>Object</code>进行转换了。</p>
<p>两者的不同之处：</p>
<ol>
<li>Callable可以返回一个类型V，而Runnable不可以</li>
<li>Callable能够抛出checked exception,而Runnable不可以。</li>
<li>Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的</li>
<li>Callable和Runnable都可以应用于executors。而Thread类只支持Runnable.</li>
</ol>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2014/04/16/java-concurrency-basic-concept/" rel="next" title="Java Concurrency - Basic Concept">
                <i class="fa fa-chevron-left"></i> Java Concurrency - Basic Concept
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2014/06/20/java-concurrency-collection/" rel="prev" title="Java Concurrency - Collection">
                Java Concurrency - Collection <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/default_avatar.png" alt="Justin Yang">
            
              <p class="site-author-name" itemprop="name">Justin Yang</p>
              <div class="site-description motion-element" itemprop="description">Blog and website of Justin Yang, blogging mainly for tech. Opinions expressed are mine.</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">28</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/yang2012" title="GitHub &rarr; https://github.com/yang2012" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:justin.yang2012@gmail.com" title="E-Mail &rarr; mailto:justin.yang2012@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://twitter.com/justinyang09" title="Twitter &rarr; https://twitter.com/justinyang09" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.facebook.com/justinyang2012" title="FB Page &rarr; https://www.facebook.com/justinyang2012" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i>FB Page</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#java-util-concurrent-atomic"><span class="nav-number">1.</span> <span class="nav-text">java.util.concurrent.atomic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Latch"><span class="nav-number">2.</span> <span class="nav-text">Latch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">2.1.</span> <span class="nav-text">CountDownLatch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Barrier"><span class="nav-number">3.</span> <span class="nav-text">Barrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">3.1.</span> <span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exchanger"><span class="nav-number">3.2.</span> <span class="nav-text">Exchanger</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Future"><span class="nav-number">4.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore"><span class="nav-number">5.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充"><span class="nav-number">6.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable-amp-Runnable"><span class="nav-number">6.1.</span> <span class="nav-text">Callable &amp; Runnable</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2013 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Justin Yang</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
